<!DOCTYPE html>

<html>
<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>

<head>
	<meta charset="UTF-8">
	<title>Canvas</title>

	<style type="text/css">
		body {
			background-color: white;
		}

		canvas {
			border-style: solid;
			border-width: 2px;
		}
	</style>

</head>

<body>

	<h1> Jose Ignacio Retamal </h1>

	<canvas id="canvas-for-ball"></canvas>

	<script type="text/javascript">

		// Gets a handle to the element with id canvasOne.
		var canvas = document.getElementById("canvas-for-ball");
		var canvasSize = {
			width: 800,
			height: 800
		}

		// Get a 2D context for the canvas.
		var ctx = canvas.getContext("2d");

		//change size of canvas.
		canvas.width = canvasSize.width;
		canvas.height = canvasSize.height;

		// The vertical location of the ball.
		var y = 10;
		var dy = 1;
		// A function to repeat every time the animation loops.

		function repeatme() {

			//clear canvas
			ctx.clearRect(0, 0, 400, 400);

			// Draw the ball (stroked, not filled).
			ctx.beginPath();
			ctx.arc(50, y, 3, 0, 2 * Math.PI);
			ctx.stroke();

			// Update the y location.
			y += dy;

			//change direction in edge
			if (y == 400 || y == 0) {
				dy = dy * (-1);
			}

			window.requestAnimationFrame(repeatme);

		}//function repeatme()

		// Get the animation going.
		//repeatme();



		class Ball {

			constructor(x, y, radius, dx, dy, colour, m) {

				//constructor variables
				this.radius = radius; //radius of the ball
				this.x = x; //x position center of the ball
				this.y = y; //y position center of the ball
				this.dx = dx; //vertical speed
				this.dy = dy; // horizontal speed
				this.slides = 7;

				//other
				this.rotation = 0; //rotation increase
				this.isClockwise = false;  //rotation direction
				this.rotationSpeed = 0;

				this.ddy = 0;
				this.ddx = 0;

				//lab 4 colour and mass
				this.colour = colour;
				this.m = m;

				//limits for the mid point of the ball
				//I make this for calculate then only once.
				this.limitsTransform = {

					xLeft: this.radius,
					xRight: canvasSize.width - this.radius,
					yTop: this.radius,
					yBottom: canvasSize.height - this.radius
				};



			}//constructor



			//Draw ball in canvas
			draw() {
				//draw normal circle
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
				ctx.stroke();

			}//draw()

			//roatate the ball by the amount parameter in isClockwise direction
			rotate(amount) {
				if (this.isClockwise) {
					this.rotation += amount + this.rotasionSpeed;
				} else {
					this.rotation -= amount + this.rotationSpeed;
				}
			}


			drawBeachball() {
				//draw normal circle
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
				ctx.stroke();

				//draw first line from righ edge to center


				//fill circle
				ctx.fillStyle = this.colour;

				ctx.fill();

				//draw lines

				//start angle for then increase
				var startAngle = 2 * Math.PI + this.rotation;

				//angle for increase so the ball can rotate
				var increaseAngle = (2 * Math.PI) / this.slides;

				//move cursor back to center
				ctx.moveTo(this.x, this.y);

				for (var i = 0; i < this.slides; i++) {

					//draw line
					ctx.lineTo(this.x + this.radius * Math.cos(startAngle), this.y + this.radius * Math.sin(startAngle));

					//move cursor back to center
					ctx.moveTo(this.x, this.y);

					//increase angle
					startAngle += increaseAngle;

				}//end for loop

				//stroke pat
				ctx.stroke();

				//draw small inner circle
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.radius * 0.95, 0, 2 * Math.PI);
				ctx.stroke();

			}//end drawBeachball() 


			/*
			*	Move method:
			*   Will change the position of the center of the ball using speed and aceleration
			*	Should be call with draw for simulate movement
			*	
			*  Accelerated
			* Using equation for Uniformly Accelerated Motion:
			* v = v0 + a(t0-t)
			* x = x0 + v0(t0-t) + (1/2)*a*(t0-t)^2
			* where v0,x0,t0 are intial velocity, postion and time
			* * If we consider each recursive call of the move function as "1 unti of time"
			* for the actual call of the function :
			* v = velocity at the end this unit of time
			* v0 = velocty at the end of last call of the function.
			* t0 =  last call, t  = actual so t0-t =1 since each call is one unit of time
			* x0 = x position at call before this
			* x = actual x postion at this call
			* so we have:
			* v0 = vf + a     (1)
			* x = x0 + v0 + (1/2)*a => x += v0 + (1/2)*a      (2)
			*/


			move() {

				//(2)
				this.y += this.dy + (1 / 2) * this.ddy;
				this.x += this.dx + (1 / 2) * this.ddx;

				//change direction when reach canvas  horizontal border

				//botton
				if (this.y >= this.limitsTransform.yBottom) {

					//back if was out of camvas
					this.y = this.limitsTransform.yBottom;

					this.changeYDirection();

				}

				//top
				if (this.y <= this.limitsTransform.yTop) {

					//back if was out of camvas
					this.y = this.limitsTransform.yTop
					this.changeYDirection();
				}

				//change direction when reach canvas  vertical border
				//right
				if (this.x >= this.limitsTransform.xRight) {

					//back if was out of camvas
					this.x = this.limitsTransform.xRight;
					this.changeXDirection();

				}
				//lest
				if (this.x <= this.limitsTransform.xLeft) {

					//back if was out of camvas
					this.x = this.limitsTransform.xLeft;
					this.changeXDirection();
				}

				//(1)
				this.dy += this.ddy;
				this.dx += this.ddx;

			}//end move()




			//for resize
			resize(radius) {
				this.radius = radius;

			}//resize(x,y)

			changeYDirection() {
				this.dy = this.dy * (-1);
			}

			changeXDirection() {
				this.dx = this.dx * (-1);
			}

			invertRotation() {

				if (this.isClockwise) {

					this.isClockwise = false;

				} else {

					this.isClockwise = true;
				}

			}//end of invertRotation()

			changeXSpeed(amount) {

				this.dx += amount;
			}

		}//end of class Ball

		//create a new ball
		//(x, y, radius, dx, dy,colour,m)
		var myBall = new Ball(80, 120, 80, 3, 10, "red", 1);
		myBall.ddy = 1;

		var myBall1 = new Ball(456, 560, 80, 1, 5, "blue", 1);
		//myBall1.ddy = 5;


		function detectCollision(b1, b2) {
			var distanceForCollision = b1.radius + b2.radius;
			var actualDistance = Math.sqrt(Math.pow(b2.x - b1.x, 2) + Math.pow(b2.y - b1.y, 2));
			//console.log("distance: " + distanceForCollision);
			//console.log(" actuan d :" + actualDistance);
			if (actualDistance <= distanceForCollision) {
				console.log("Collision!!" + actualDistance);

				//calculate x and y distance beetwen balls
				var dx = b1.x - b2.x;
				var dy = b1.y - b2.y;
				var collisionAngle = Math.atan2(dy, dx);
				console.log(collisionAngle);

				//calculete total magnitud
				var mag1 = Math.sqrt(b1.dx * b1.dx + b1.dy * b1.dy);
				var mag2 = Math.sqrt(b2.dx * b2.dx + b2.dy * b2.dy);

				console.log("m1" + mag1 + "m2" + mag2);

				//determine balls direction
				var d1 = Math.atan2(b1.dy, b1.dx);
				var d2 = Math.atan2(b2.dy, b2.dx);

				console.log("d1" + d1 + "d2" + d2);

				//calculate new x and y vel
				var dx1_new = mag1 * Math.cos(d1 - collisionAngle);
				var dy1_new = mag1 * Math.sin(d1 - collisionAngle);
				var dx2_new = mag2 * Math.cos(d2 - collisionAngle);
				var dy2_new = mag2 * Math.sin(d2 - collisionAngle);

				//final x speed for ball 1
				var dx1_final = ((b1.m - b2.m) * dx1_new + ((b2.m + b2.m) * dx2_new)) / (b1.m + b2.m);
				var dx2_final = ((b1.m + b1.m) * dx1_new + ((b2.m - b1.m) * dx2_new)) / (b1.m + b2.m);

				//y is the same
				var dy1_final = dy1_new;
				var dy2_final = dy2_new;

				

				//final velocity in original 
				b1.dx = Math.cos(collisionAngle) * dx1_final + Math.cos(collisionAngle + Math.PI / 2) * dy1_final;
				b1.dy = Math.sin(collisionAngle) * dx1_final + Math.sin(collisionAngle + Math.PI / 2) * dy1_final;

				b2.dy = Math.cos(collisionAngle) * dx2_final + Math.cos(collisionAngle + Math.PI / 2) * dy2_final;
				b2.dx = Math.sin(collisionAngle) * dx2_final + Math.sin(collisionAngle + Math.PI / 2) * dy2_final;

				//change color
				var temp = b1.colour;
				b1.colour = b2.colour;
				b2.colour = temp;
			}
		}

		//funtion for call recursively
		function repeatBallBounce() {

			//clear canvas
			ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);

	

			//ball actions
			myBall.rotate(0.01);
			myBall.move();

			myBall.drawBeachball();

			myBall1.rotate(0.01);
			myBall1.move();
			myBall1.drawBeachball();

			//collision detection
			detectCollision(myBall, myBall1);	

			//recursive call
			window.requestAnimationFrame(repeatBallBounce);

		}//function repeatBallBounce()

		//start recursive call
		repeatBallBounce();

		//key event

		// Add a Javascript event listener to the keypress event.
		window.addEventListener("keypress", function (event) {
			// Just log the event to the console.

			console.log(event);
			/*
			//right arrow
			if (event.keyCode == 39) {
				myBall.dx += 1;
				console.log("here");
			}*/
		});

		$(document.body).on('keydown', function (e) {
			console.log(e.which);
			switch (e.which) {
				// key code for left arrow
				case 37:
					console.log('left arrow key pressed!');
					myBall.dx -= 1;

					break;

				// key code for right arrow
				case 39:
					console.log('right arrow key pressed!');
					myBall.dx += 1;
					break;
				// key up pressed
				case 38:
					myBall.dy -= 5;
					break;
				//key down pressed
				case 40:
					myBall.dy += 1;
					console.log('top arrow key pressed!');
					break;

				case 82://left
					myBall.rotationSpeed += 10;
					console.log('r key pressed!');
					break;
				case 80: //right
					console.log('p arrow key pressed!');
					myBall.rotationSpeed -= 10;
					break;

			}
		});

		//mouse event
		var canvasPosition = {
			x: canvas.offsetLeft,
			y: canvas.offsetTop
		}
		canvas.addEventListener("click", function (event) {


			var mouse = {
				x: event.pageX - canvasPosition.x,
				y: event.pageY - canvasPosition.y
			}


			myBall.x = mouse.x;
			myBall.y = mouse.y;
			myBall.draw();

			noClicks += 1;
			console.log(noClicks);


		});

		//second ball


	</script>

</body>

</html>