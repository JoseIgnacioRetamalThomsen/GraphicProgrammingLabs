<!DOCTYPE html>

<html>
<script src="https://code.jquery.com/jquery-3.1.0.min.js"></script>

<head>
	<meta charset="UTF-8">
	<title>Canvas</title>

	<style type="text/css">
		body {
			background-color: white;
		}

		canvas {
			border-style: solid;
			border-width: 2px;
		}
	</style>

</head>

<body>

	<h1> Jose Ignacio Retamal </h1>

	<canvas id="canvas-for-ball"></canvas>

	<script type="text/javascript">

		// Gets a handle to the element with id canvasOne.
		var canvas = document.getElementById("canvas-for-ball");
		var canvasSize = {
			width: 800,
			height: 800
		}

		// Get a 2D context for the canvas.
		var ctx = canvas.getContext("2d");

		//change size of canvas.
		canvas.width = canvasSize.width;
		canvas.height = canvasSize.height;

		// The vertical location of the ball.
		var y = 10;
		var dy = 1;
		// A function to repeat every time the animation loops.

		function repeatme() {

			//clear canvas
			ctx.clearRect(0, 0, 400, 400);

			// Draw the ball (stroked, not filled).
			ctx.beginPath();
			ctx.arc(50, y, 3, 0, 2 * Math.PI);
			ctx.stroke();

			// Update the y location.
			y += dy;

			//change direction in edge
			if (y == 400 || y == 0) {
				dy = dy * (-1);
			}

			window.requestAnimationFrame(repeatme);

		}//function repeatme()

		// Get the animation going.
		//repeatme();



		class Ball {

			constructor(x, y, radius, dx, dy, slides) {

				//constructor variables
				this.radius = radius; //radius of the ball
				this.x = x; //x position center of the ball
				this.y = y; //y position center of the ball
				this.dx = dx; //vertical speed
				this.dy = dy; // horizontal speed
				this.slides = slides

				//other
				this.rotation = 0; //rotation increase
				this.isClockwise = false;  //rotation direction
				this.rotationSpeed = 0;

				this.ddy = 0;
				this.ddx = 0;

				//limits for the mid point of the ball
				//I make this for calculate then only once.
				this.limitsTransform = {

					xLeft: this.radius,
					xRight: canvasSize.width - this.radius,
					yTop: this.radius,
					yBottom: canvasSize.height - this.radius
				};

				

			}//constructor

			

			//Draw ball in canvas
			draw() {
				//draw normal circle
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
				ctx.stroke();

			}//draw()

			//roatate the ball by the amount parameter in isClockwise direction
			rotate(amount) {
				if (this.isClockwise) {
					this.rotation += amount + this.rotasionSpeed;
				} else {
					this.rotation -= amount + this.rotationSpeed;
				}
			}


			drawBeachball() {
				//draw normal circle
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
				ctx.stroke();

				//draw first line from righ edge to center


				//fill circle
				ctx.fillStyle = "orange";

				ctx.fill();

				//draw lines

				//start angle for then increase
				var startAngle = 2 * Math.PI + this.rotation;

				//angle for increase so the ball can rotate
				var increaseAngle = (2 * Math.PI) / this.slides;

				//move cursor back to center
				ctx.moveTo(this.x, this.y);

				for (var i = 0; i < this.slides; i++) {

					//draw line
					ctx.lineTo(this.x + this.radius * Math.cos(startAngle), this.y + this.radius * Math.sin(startAngle));

					//move cursor back to center
					ctx.moveTo(this.x, this.y);

					//increase angle
					startAngle += increaseAngle;

				}//end for loop

				//stroke pat
				ctx.stroke();

				//draw small inner circle
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.radius * 0.95, 0, 2 * Math.PI);
				ctx.stroke();

			}//end drawBeachball() 


			/*
			*	Move method:
			*   Will change the position of the center of the ball using speed and aceleration
			*	Should be call with draw for simulate movement
			*	
			*  Accelerated
			* Using equation for Uniformly Accelerated Motion:
			* v = v0 + a(t0-t)
			* x = x0 + v0(t0-t) + (1/2)*a*(t0-t)^2
			* where v0,x0,t0 are intial velocity, postion and time
			* * If we consider each recursive call of the move function as "1 unti of time"
			* for the actual call of the function :
			* v = velocity at the end this unit of time
			* v0 = velocty at the end of last call of the function.
			* t0 =  last call, t  = actual so t0-t =1 since each call is one unit of time
			* x0 = x position at call before this
			* x = actual x postion at this call
			* so we have:
			* v0 = vf + a     (1)
			* x = x0 + v0 + (1/2)*a => x += v0 + (1/2)*a      (2)
			*/


			move() {

				//(2)
				this.y += this.dy + (1 / 2) * this.ddy;
				this.x += this.dx + (1 / 2) * this.ddx;

				//change direction when reach canvas  horizontal border

				//botton
				if (this.y >= this.limitsTransform.yBottom) {

					//back if was out of camvas
					this.y = this.limitsTransform.yBottom;

					this.changeYDirection();

				}

				//top
				if (this.y <= this.limitsTransform.yTop) {

					//back if was out of camvas
					this.y = this.limitsTransform.yTop
					this.changeYDirection();
				}

				//change direction when reach canvas  vertical border
				//right
				if (this.x >= this.limitsTransform.xRight) {

					//back if was out of camvas
					this.x = this.limitsTransform.xRight;
					this.changeXDirection();

				}
				//lest
				if (this.x <= this.limitsTransform.xLeft) {

					//back if was out of camvas
					this.x = this.limitsTransform.xLeft;
					this.changeXDirection();
				}

				//(1)
				this.dy += this.ddy;
				this.dx += this.ddx;

			}//end move()




			//for resize
			resize(radius) {
				this.radius = radius;

			}//resize(x,y)

			changeYDirection() {
				this.dy = this.dy * (-1);
			}

			changeXDirection() {
				this.dx = this.dx * (-1);
			}

			invertRotation() {

				if (this.isClockwise) {

					this.isClockwise = false;

				} else {

					this.isClockwise = true;
				}

			}//end of invertRotation()

			changeXSpeed(amount) {

				this.dx += amount;
			}

		}//end of class Ball

		//create a new ball
		var myBall = new Ball(80, 120, 80, 2, 2, 7);
		myBall.ddy = 2;

		var myBall1 = new Ball(80, 80, 80, 4, 4, 7);
		myBall1.ddy = 5;
		//funtion for call recursively
		function repeatBallBounce() {

			//clear canvas
			ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);

			//ball actions
			myBall.rotate(0.01);
			myBall.move();

			myBall.drawBeachball();

			myBall1.rotate(0.01);
			myBall1.move();
			myBall1.drawBeachball();

			//recursive call
			window.requestAnimationFrame(repeatBallBounce);

		}//function repeatBallBounce()

		//start recursive call
		repeatBallBounce();

		//key event

		// Add a Javascript event listener to the keypress event.
		window.addEventListener("keypress", function (event) {
			// Just log the event to the console.

			console.log(event);
			/*
			//right arrow
			if (event.keyCode == 39) {
				myBall.dx += 1;
				console.log("here");
			}*/
		});

		$(document.body).on('keydown', function (e) {
			console.log(e.which);
			switch (e.which) {
				// key code for left arrow
				case 37:
					console.log('left arrow key pressed!');
					myBall.dx -= 1;

					break;

				// key code for right arrow
				case 39:
					console.log('right arrow key pressed!');
					myBall.dx += 1;
					break;
				// key up pressed
				case 38:
					myBall.dy -= 5;
					break;
				//key down pressed
				case 40:
					myBall.dy += 1;
					console.log('top arrow key pressed!');
					break;

				case 82://left
					myBall.rotationSpeed += 10;
					console.log('r key pressed!');
					break;
				case 80: //right
					console.log('p arrow key pressed!');
					myBall.rotationSpeed -= 10;
					break;

			}
		});

		//mouse event
		var canvasPosition = {
			x: canvas.offsetLeft,
			y: canvas.offsetTop
		}
		canvas.addEventListener("click", function (event) {


			var mouse = {
				x: event.pageX - canvasPosition.x,
				y: event.pageY - canvasPosition.y
			}


			myBall.x = mouse.x;
			myBall.y = mouse.y;
			myBall.draw();

			noClicks += 1;
			console.log(noClicks);


		});

		//second ball


	</script>

</body>

</html>